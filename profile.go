// Package profile provides a simple way to manage runtime/pprof
// profiling of your Go application.
package profile

import (
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"sync/atomic"
)

// started counts the number of times Start has been called
var started uint32

type mode int

const (
	cpuMode mode = iota
	memMode
	blockMode
)

func (m mode) filename() string {
	return [...]string{"cpu.pprof", "mem.pprof", "block.pprof"}[m]
}

type profile struct {
	// quiet suppresses informational messages during profiling.
	quiet bool

	// noShutdownHook controls whether the profiling package should
	// hook SIGINT to write profiles cleanly.
	noShutdownHook bool

	// mode holds the type of profiling that will be made
	mode mode

	// path holds the base path where various profiling files are  written.
	// If blank, the base path will be generated by ioutil.TempDir.
	path string

	// writeTo holds the writer that the profile will be written to. It is
	// nil by default.
	writeTo io.Writer

	// memProfileRate holds the rate for the memory profile.
	memProfileRate int

	// closers holds the cleanup functions that run after each profile
	closers []func()
}

// NoShutdownHook controls whether the profiling package should
// hook SIGINT to write profiles cleanly.
// Programs with more sophisticated signal handling should set
// this to true and ensure the Stop() function returned from Start()
// is called during shutdown.
func NoShutdownHook(p *profile) { p.noShutdownHook = true }

// Quiet suppresses informational messages during profiling.
func Quiet(p *profile) { p.quiet = true }

// CPUProfile controls if cpu profiling will be enabled. It disables any previous profiling settings.
func CPUProfile(p *profile) { p.mode = cpuMode }

// DefaultMemProfileRate is the default memory profiling rate.
// See also http://golang.org/pkg/runtime/#pkg-variables
const DefaultMemProfileRate = 4096

// MemProfile controls if memory profiling will be enabled. It disables any previous profiling settings.
func MemProfile(p *profile) {
	p.memProfileRate = DefaultMemProfileRate
	p.mode = memMode
}

// MemProfileRate controls if memory profiling will be enabled. Additionally, it takes a parameter which
// allows the setting of the memory profile rate.
func MemProfileRate(rate int) func(*profile) {
	return func(p *profile) {
		p.memProfileRate = rate
		p.mode = memMode
	}
}

// BlockProfile controls if block (contention) profiling will be enabled. It disables any previous profiling settings.
func BlockProfile(p *profile) { p.mode = blockMode }

// ProfilePath controls the base path where various profiling
// files are written. If blank, the base path will be generated
// by ioutil.TempDir.
func ProfilePath(path string) func(*profile) {
	return func(p *profile) {
		p.path = path
	}
}

// Stop stops the profile and flushes any unwritten data.
func (p *profile) Stop() {
	for _, c := range p.closers {
		c()
	}
}

// WriteTo directs all profiling output towards the given io.Writer
func WriteTo(w io.Writer) func(*profile) {
	return func(p *profile) {
		p.writeTo = w
	}
}

// log outputs a formatted message to the console, unless set to quiet.
func (p *profile) log(fmt string, args ...interface{}) {
	if !p.quiet {
		log.Printf(fmt, args)
	}
}

// writer retuns an io.Writer that the profile can be written to.
func (p *profile) writer() io.Writer {
	if p.writeTo != nil {
		p.log("profile: profiling enabled, writing...")
		return p.writeTo
	}
	path, err := func() (string, error) {
		if p := p.path; p != "" {
			return p, os.MkdirAll(p, 0777)
		}
		return ioutil.TempDir("", "profile")
	}()

	fn := filepath.Join(path, p.mode.filename())
	f, err := os.Create(fn)
	if err != nil {
		log.Fatalf("profile: could not create profile %q: %v", fn, err)
	}
	p.log("profile: profiling enabled, %s", fn)
	return f
}

// Start starts a new profiling session.
// The caller should call the Stop method on the value returned
// to cleanly stop profiling.
func Start(options ...func(*profile)) interface {
	Stop()
} {
	if !atomic.CompareAndSwapUint32(&started, 0, 1) {
		log.Fatal("profile: Start() already called")
	}

	var prof profile
	for _, option := range options {
		option(&prof)
	}

	w := prof.writer()
	switch prof.mode {
	case cpuMode:
		pprof.StartCPUProfile(w)
		prof.closers = append(prof.closers, func() {
			pprof.StopCPUProfile()
		})
	case memMode:
		old := runtime.MemProfileRate
		runtime.MemProfileRate = prof.memProfileRate
		prof.closers = append(prof.closers, func() {
			pprof.Lookup("heap").WriteTo(w, 0)
			runtime.MemProfileRate = old
		})
	case blockMode:
		runtime.SetBlockProfileRate(1)
		prof.closers = append(prof.closers, func() {
			pprof.Lookup("block").WriteTo(w, 0)
			runtime.SetBlockProfileRate(0)
		})
	}

	if !prof.noShutdownHook {
		go func() {
			c := make(chan os.Signal, 1)
			signal.Notify(c, os.Interrupt)
			<-c

			prof.log("profile: caught interrupt, stopping profiles")
			prof.Stop()

			os.Exit(0)
		}()
	}

	prof.closers = append(prof.closers, func() {
		if c, ok := w.(io.Closer); ok {
			c.Close()
		}
	}, func() {
		atomic.SwapUint32(&started, 0)
	})

	return &prof
}
